// Copyright (c) 2026 The INTcoin Core developers
// Distributed under the MIT software license

// Define mock CBlock and CBlockIndex BEFORE including headers
// This ensures the complete type is available when parallel_validation.h is included
namespace intcoin {
    class CBlock {
    public:
        CBlock() = default;
        CBlock(const CBlock&) = default;
        CBlock(CBlock&&) = default;
        CBlock& operator=(const CBlock&) = default;
        CBlock& operator=(CBlock&&) = default;
        ~CBlock() = default;
    };

    class CBlockIndex {
    public:
        CBlockIndex() = default;
        CBlockIndex(const CBlockIndex&) = default;
        CBlockIndex(CBlockIndex&&) = default;
        CBlockIndex& operator=(const CBlockIndex&) = default;
        CBlockIndex& operator=(CBlockIndex&&) = default;
        ~CBlockIndex() = default;
    };
}

#include <intcoin/ibd/parallel_validation.h>
#include <iostream>
#include <cassert>
#include <thread>
#include <chrono>

using namespace intcoin::ibd;
using intcoin::CBlock;
using intcoin::CBlockIndex;

// Test helpers
#define TEST_ASSERT(condition, message) \
    do { \
        if (!(condition)) { \
            std::cerr << "FAIL: " << message << std::endl; \
            return false; \
        } \
    } while(0)

#define RUN_TEST(test_func) \
    do { \
        std::cout << "Running " << #test_func << "... "; \
        if (test_func()) { \
            std::cout << "PASS" << std::endl; \
            passed++; \
        } else { \
            std::cout << "FAIL" << std::endl; \
            failed++; \
        } \
        total++; \
    } while(0)

// Test: Thread pool initialization
bool test_threadpool_init() {
    ThreadPool pool(4);

    TEST_ASSERT(pool.GetThreadCount() == 4, "Thread count should be 4");
    TEST_ASSERT(pool.GetQueueSize() == 0, "Queue should be empty initially");

    return true;
}

// Test: Thread pool task execution
bool test_threadpool_execution() {
    ThreadPool pool(2);

    std::atomic<int> counter{0};

    for (int i = 0; i < 10; i++) {
        pool.Enqueue([&counter]() {
            counter++;
        });
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(100));

    TEST_ASSERT(counter == 10, "All tasks should be executed");

    return true;
}

// Test: Thread pool queue management
bool test_threadpool_queue() {
    ThreadPool pool(1);

    std::atomic<int> counter{0};

    for (int i = 0; i < 100; i++) {
        pool.Enqueue([&counter]() {
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
            counter++;
        });
    }

    TEST_ASSERT(pool.GetQueueSize() > 0, "Queue should have pending tasks");

    std::this_thread::sleep_for(std::chrono::milliseconds(150));

    TEST_ASSERT(counter == 100, "All tasks should complete");

    return true;
}

// Test: Parallel block processor initialization
bool test_processor_init() {
    ParallelBlockProcessor processor;

    auto stats = processor.GetStats();
    TEST_ASSERT(stats.blocks_validated == 0, "Initial blocks validated should be 0");
    TEST_ASSERT(stats.blocks_rejected == 0, "Initial blocks rejected should be 0");

    return true;
}

// Test: Single block submission
bool test_single_block_submission() {
    ParallelBlockProcessor processor;

    CBlock block;
    CBlockIndex index;

    auto future = processor.SubmitBlock(block, &index);

    TEST_ASSERT(future.valid(), "Future should be valid");

    auto result = future.get();
    TEST_ASSERT(result.valid, "Block should be valid (mock always returns valid)");

    return true;
}

// Test: Multiple blocks submission
bool test_multiple_blocks_submission() {
    ParallelBlockProcessor processor;

    std::vector<ValidationFuture> futures;

    for (int i = 0; i < 10; i++) {
        CBlock block;
        CBlockIndex index;
        futures.push_back(processor.SubmitBlock(block, &index));
    }

    for (auto& future : futures) {
        auto result = future.get();
        TEST_ASSERT(result.valid, "All blocks should be valid");
    }

    auto stats = processor.GetStats();
    TEST_ASSERT(stats.blocks_validated == 10, "Should have validated 10 blocks");

    return true;
}

// Test: Serial validation correctness
bool test_serial_validation() {
    ParallelBlockProcessor processor;

    std::vector<bool> results;

    for (int i = 0; i < 5; i++) {
        CBlock block;
        CBlockIndex index;
        auto future = processor.SubmitBlock(block, &index);
        auto result = future.get();
        results.push_back(result.valid);
    }

    for (bool r : results) {
        TEST_ASSERT(r, "All serial validations should succeed");
    }

    return true;
}

// Test: Out-of-order validation
bool test_out_of_order_validation() {
    ParallelBlockProcessor processor;

    std::vector<ValidationFuture> futures;

    // Submit blocks
    for (int i = 0; i < 20; i++) {
        CBlock block;
        CBlockIndex index;
        futures.push_back(processor.SubmitBlock(block, &index));
    }

    // Wait for all (they may complete out of order internally)
    for (auto& future : futures) {
        auto result = future.get();
        TEST_ASSERT(result.valid, "Block should be valid");
    }

    auto stats = processor.GetStats();
    TEST_ASSERT(stats.blocks_validated == 20, "Should have validated 20 blocks");

    return true;
}

// Test: Concurrent validation performance
bool test_concurrent_validation_performance() {
    ParallelBlockProcessor processor;

    auto start = std::chrono::high_resolution_clock::now();

    std::vector<ValidationFuture> futures;
    for (int i = 0; i < 100; i++) {
        CBlock block;
        CBlockIndex index;
        futures.push_back(processor.SubmitBlock(block, &index));
    }

    for (auto& future : futures) {
        future.get();
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    std::cout << "(took " << duration.count() << "ms) ";

    TEST_ASSERT(duration.count() < 1000, "Should complete in under 1 second");

    return true;
}

// Test: Validation statistics
bool test_validation_statistics() {
    ParallelBlockProcessor processor;

    for (int i = 0; i < 10; i++) {
        CBlock block;
        CBlockIndex index;
        auto future = processor.SubmitBlock(block, &index);
        future.get();
    }

    auto stats = processor.GetStats();

    TEST_ASSERT(stats.blocks_validated == 10, "Should have 10 validated blocks");
    TEST_ASSERT(stats.total_validation_time_ms >= 0, "Total time should be non-negative");

    return true;
}

// Test: Thread safety
bool test_thread_safety() {
    ParallelBlockProcessor processor;

    std::vector<std::thread> threads;
    std::atomic<int> successful{0};

    for (int t = 0; t < 4; t++) {
        threads.emplace_back([&processor, &successful]() {
            for (int i = 0; i < 25; i++) {
                CBlock block;
                CBlockIndex index;
                auto future = processor.SubmitBlock(block, &index);
                auto result = future.get();
                if (result.valid) {
                    successful++;
                }
            }
        });
    }

    for (auto& thread : threads) {
        thread.join();
    }

    TEST_ASSERT(successful == 100, "All 100 submissions should succeed");

    return true;
}

// Test: Reset statistics
bool test_reset_statistics() {
    ParallelBlockProcessor processor;

    for (int i = 0; i < 5; i++) {
        CBlock block;
        CBlockIndex index;
        processor.SubmitBlock(block, &index).get();
    }

    processor.ResetStats();

    auto stats = processor.GetStats();
    TEST_ASSERT(stats.blocks_validated == 0, "Stats should be reset");
    TEST_ASSERT(stats.total_validation_time_ms == 0, "Time should be reset");

    return true;
}

// Test: Get thread count
bool test_get_thread_count() {
    ParallelBlockProcessor processor;

    uint32_t thread_count = processor.GetThreadCount();
    TEST_ASSERT(thread_count > 0, "Thread count should be positive");
    TEST_ASSERT(thread_count <= 32, "Thread count should be reasonable");

    return true;
}

int main() {
    int passed = 0;
    int failed = 0;
    int total = 0;

    std::cout << "=== Parallel Validation Tests ===" << std::endl;
    std::cout << std::endl;

    RUN_TEST(test_threadpool_init);
    RUN_TEST(test_threadpool_execution);
    RUN_TEST(test_threadpool_queue);
    RUN_TEST(test_processor_init);
    RUN_TEST(test_single_block_submission);
    RUN_TEST(test_multiple_blocks_submission);
    RUN_TEST(test_serial_validation);
    RUN_TEST(test_out_of_order_validation);
    RUN_TEST(test_concurrent_validation_performance);
    RUN_TEST(test_validation_statistics);
    RUN_TEST(test_thread_safety);
    RUN_TEST(test_reset_statistics);
    RUN_TEST(test_get_thread_count);

    std::cout << std::endl;
    std::cout << "=== Test Results ===" << std::endl;
    std::cout << "Total: " << total << std::endl;
    std::cout << "Passed: " << passed << std::endl;
    std::cout << "Failed: " << failed << std::endl;
    std::cout << std::endl;

    return (failed == 0) ? 0 : 1;
}
